# Exercise Solution: Building Agents with Tools in Python

### Solution Walkthrough

This solution demonstrates how to build a financial assistant agent capable of using external Python functions (tools) via OpenAI's function-calling capabilities. The key is to define the tools, describe them to the model using a schema, and then orchestrate the multi-step conversation.

First, we implement the `calculate_compound_interest` function. This function takes the principal, rate, time, and compounding frequency as inputs, applies the standard compound interest formula, and returns a dictionary containing the calculated financial details.

Next, we define the schemas for our tools. This JSON structure describes each function's purpose, parameters, types, and which parameters are required. This schema is how the OpenAI model understands what the tools do and how to call them. We also create a `FUNCTIONS` dictionary to map the string name of each tool to its corresponding Python function object, which allows us to execute the function call dynamically.

The core logic resides in the `agentic_tool_call` function. In the first API call, we use the `tool_choice` parameter to force the model to use the specific tool we've selected, removing any ambiguity. After executing the tool, we construct a new list of messages for a second API call. Crucially, this includes adding a message with `role: "tool"` that contains the output from our Python function. This gives the model the context it needs to generate a final, human-readable answer based on the tool's result.

Finally, we implement the test functions. These functions format a user-friendly prompt and pass the necessary arguments to our `agentic_tool_call` function to trigger the entire agentic loop.

Running the example usage cell now executes both tool calls successfully and prints the final, natural-language responses generated by the model.

### Key Takeaway

> You can force an OpenAI model to use a specific function and build a multi-turn conversation by defining tool schemas, using `tool_choice`, and sending tool results back to the model for a final, summarized response.